// 1. 1/1은 첫 번째, 1/2 2/1은 두 번째, 1/3 2/2 3/1은 세 번째. 규칙성이 벌써 보인다.
// 2. 가령 첫 번째는 합이 2, 두 번째는 3, 세 번째는 4이다. 또한 오른쪽은 내림차순, 왼쪽은 오름차순이다.
// 3. 첫 번째는 1개, 두 번째는 2개, 세 번째는 3개, 네 번째는(4321 내림차순) 4개이다.
// 4. 쉽네. 굳이 오른쪽 왼쪽 둘 다 볼 필요도 없을듯. 일단 몇번째인지 확인하고, 그 이전 개수 전부 더한 다음에, 왼쪽만 보 고 오름차순으로 구해주면 될듯. 가령 1/4이면 합이 5, 네 번째니까(1/1이 첫 번째, 합이랑은 무관, 최대 숫자랑 관련있다고 생 각하면 될듯), 1+2+3 = 6. 거기다가 1/4니까 6+1해서 7번째.
// 5. 아 근데 input값은 번째이다. 가령 7이 들어오면 1/4을 낼 수 있는지를 확인하는 것. -> -1 -2 -3 -4해서 음수 되기 전까 지 만들고, 이후에 음수되기직전숫자/(최댓값-음수되기직전숫자) 로 출력하면 될듯. >> -1 -2 세어줄 counter(즉 레벨링 요소)  필요. 그리고 value인 count도 필요.
// 최대수는 10,000,000

#include <iostream>
using namespace std;

int main(void)
{
        int count, counter = 0, tmp; // counter를 1이 되어야함. 이유는 1/1이 level 1(첫 번째)이기 때문.
                                                                 // 하지만 일단은 0으로 구현. 왜냐면 dowhile 써서 그냥 counter++하고 보려고. -> 아까 밑에 dowhile 쓸 필요 없다고 했는데 명분 만들었다.
        cin >> count;

        do
        {
                counter++;
                tmp = count;
                count -= counter;
        } while (count > 0); // count가 음수가 '되면' 멈추기에 음수 되기 직전 수를 구해야하는데...
                                                 // 그렇다고 while(1)하고 안에 if문을 만들기엔 너무 redundancy인데...
                                                 // tmp를 사용하는 걸로 해결하자. 값 저장해두면 되지
                                                 // 써놓고 보니까 굳이 dowhile 쓸 필요가 없었네. 컴파일러가 최적화 해주 겠지
        if (counter % 2 == 0)
                cout << tmp << '/' << counter + 1 - tmp; // tmp는 0일 수 없음. 왜냐면 count가 0이기 전 값을 tmp에 저장해놓기 때문
                                                                                                 // 또한 counter는 count가 음수가 '될 때의' count 값이기에(count -= counter한 값이 count < 0이면 다이니까. counter가 ++되는 게 count < 0 이전이 다.) counter값은 해당 level의 최댓값이다.
                                                                                                 // counter+1 - tmp을 한 이유는 counter+1은 최댓값+1임. 그리고, 해당 분수에서 최댓값은 항상 1과 맺어짐. 가령 level 1이면 1/1이고, level 3이면 1/3임. 따라서 counter+1은 왼쪽과 오른쪽의 합이 되며, 어느 상황에서든 적용됨.(가령 level 4에선 1/4일텐데, 2/3 3/2 4/1 전부 왼+오는 5임)
                                                                                                 // 따라서 그냥 counter+1로 왼+오를 만들어줌
        else
                cout << counter + 1 - tmp << '/' << tmp; // 아니 난 1/1 1/2 2/1 1/3 2/2 3/1 1/4 2/3 이렇게 되는줄 알았는데...
                                                                                                 // 전혀 아니고;; 1/1 1/2 2/1 3/1 2/2 1/3 1/4 2/3 지그재그고;;;
                                                                                                 // 조건문으로 level이  홀수면 그냥 반대로 출력하게 했다.
        cout << endl;
        return 0;
}