// 1. 한 변에 점이 늘어나는 개수는 2의 n-1승(가령 1번이면 한 변에 1개씩 총 4개, 2번이면 한 변에 2개씩 총 8개)
// 2. 근데 그걸 새롭게 생기는 모든 변에 전부 적용해야함. -> 가령 1번은 변 2개 생성, 2번은 4개 생성.
// 3. 초기상태는 점 4개. 이후에 최소단위인 네모 하나당 점 5개씩 추가됨.(그러나 점은 하나의 상자당 최대 4개를 공유)
// 4. 이거는 1 -> 2 -> 3 -> 이렇게 누적하는 식으로 만들면 안됨. 왜냐면 n차 마다 늘어나는 알고리즘이 너무 기하급수적이기 때문.
// 5. 따라서 단순하게 하나의 row에 들어가는 점의 개수왜 전체 개수의 상관관계로 생각해볼 것.
// 6. 초기상태 = 하나의 row에 2개, 총 2개의 column 따라서 총 4개의 점.
// 7. 1번 = 하나의 row에 3개, 총 3개의 column 따라서 총 9개의 점.
// 8. 2번 = 하나의 row에 5개, 총 5개의 column 따라서 총 25개의 점.
// 9. 일단 점의 개수는 n승임을 확인 가능함. 그럼 점이 늘어나는 규칙성만 찾으면 해결 가능.
// 10. 그거는 2에 써놓은 logic을 사용하면 해결 가능. 가령 1번일 땐 꼭짓점 제외하고 점이 생길 곳이 row의 가운데 하나 뿐.
// 11. 2번일 땐 row의 가운데 점이 하나 더 찍혀서 2개의 변을 만들어, 총 4개의 사각형을 만들었으니, 하나의 row에 찍을 수  있는 점의 개수가 2개로 늘어남. 이후엔 4개, 8개, 기하급수적으로 늘어날 것.

#include <iostream>
#include <cmath> // fmod, pow 등 사용할 게 많은 좋은 함수.
using namespace std;

int main(void)
{
        int count;
        int sum = 2;
        cin >> count;

        for(int i = 0; i < count; i++)
        {
                sum += pow(2, i);
        }
        cout << sum * sum << endl;

        return 0;
}